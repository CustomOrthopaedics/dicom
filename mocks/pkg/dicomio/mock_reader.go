// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/dicomio/reader.go

// Package mock_dicomio is a generated GoMock package.
package mock_dicomio

import (
	gomock "github.com/golang/mock/gomock"
	reflect "reflect"
)

// MockReader is a mock of Reader interface
type MockReader struct {
	ctrl     *gomock.Controller
	recorder *MockReaderMockRecorder
}

// MockReaderMockRecorder is the mock recorder for MockReader
type MockReaderMockRecorder struct {
	mock *MockReader
}

// NewMockReader creates a new mock instance
func NewMockReader(ctrl *gomock.Controller) *MockReader {
	mock := &MockReader{ctrl: ctrl}
	mock.recorder = &MockReaderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockReader) EXPECT() *MockReaderMockRecorder {
	return m.recorder
}

// Read mocks base method
func (m *MockReader) Read(p []byte) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Read", p)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Read indicates an expected call of Read
func (mr *MockReaderMockRecorder) Read(p interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Read", reflect.TypeOf((*MockReader)(nil).Read), p)
}

// ReadN mocks base method
func (m *MockReader) ReadN(n uint32) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadN", n)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadN indicates an expected call of ReadN
func (mr *MockReaderMockRecorder) ReadN(n interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadN", reflect.TypeOf((*MockReader)(nil).ReadN), n)
}

// ReadUInt16 mocks base method
func (m *MockReader) ReadUInt16() (uint16, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadUInt16")
	ret0, _ := ret[0].(uint16)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadUInt16 indicates an expected call of ReadUInt16
func (mr *MockReaderMockRecorder) ReadUInt16() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadUInt16", reflect.TypeOf((*MockReader)(nil).ReadUInt16))
}

// ReadUInt32 mocks base method
func (m *MockReader) ReadUInt32() (uint32, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadUInt32")
	ret0, _ := ret[0].(uint32)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadUInt32 indicates an expected call of ReadUInt32
func (mr *MockReaderMockRecorder) ReadUInt32() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadUInt32", reflect.TypeOf((*MockReader)(nil).ReadUInt32))
}

// ReadInt16 mocks base method
func (m *MockReader) ReadInt16() (int16, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadInt16")
	ret0, _ := ret[0].(int16)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadInt16 indicates an expected call of ReadInt16
func (mr *MockReaderMockRecorder) ReadInt16() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadInt16", reflect.TypeOf((*MockReader)(nil).ReadInt16))
}

// ReadInt32 mocks base method
func (m *MockReader) ReadInt32() (int32, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadInt32")
	ret0, _ := ret[0].(int32)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadInt32 indicates an expected call of ReadInt32
func (mr *MockReaderMockRecorder) ReadInt32() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadInt32", reflect.TypeOf((*MockReader)(nil).ReadInt32))
}

// ReadString mocks base method
func (m *MockReader) ReadString(n uint32) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadString", n)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadString indicates an expected call of ReadString
func (mr *MockReaderMockRecorder) ReadString(n interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadString", reflect.TypeOf((*MockReader)(nil).ReadString), n)
}

// Skip mocks base method
func (m *MockReader) Skip(n uint) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Skip", n)
	ret0, _ := ret[0].(error)
	return ret0
}

// Skip indicates an expected call of Skip
func (mr *MockReaderMockRecorder) Skip(n interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Skip", reflect.TypeOf((*MockReader)(nil).Skip), n)
}

// PushLimit mocks base method
func (m *MockReader) PushLimit(n int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "PushLimit", n)
}

// PushLimit indicates an expected call of PushLimit
func (mr *MockReaderMockRecorder) PushLimit(n interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PushLimit", reflect.TypeOf((*MockReader)(nil).PushLimit), n)
}

// PopLimit mocks base method
func (m *MockReader) PopLimit() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "PopLimit")
}

// PopLimit indicates an expected call of PopLimit
func (mr *MockReaderMockRecorder) PopLimit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PopLimit", reflect.TypeOf((*MockReader)(nil).PopLimit))
}

// IsLimitExhausted mocks base method
func (m *MockReader) IsLimitExhausted() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsLimitExhausted")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsLimitExhausted indicates an expected call of IsLimitExhausted
func (mr *MockReaderMockRecorder) IsLimitExhausted() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsLimitExhausted", reflect.TypeOf((*MockReader)(nil).IsLimitExhausted))
}
